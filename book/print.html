<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust PS Snippets</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Utility</li><li class="chapter-item expanded "><a href="matrix.html"><strong aria-hidden="true">1.</strong> Matrix</a></li><li class="chapter-item expanded "><a href="twosat.html"><strong aria-hidden="true">2.</strong> 2-SAT</a></li><li class="chapter-item expanded "><a href="prng.html"><strong aria-hidden="true">3.</strong> Pseudo Random Number Generator</a></li><li class="chapter-item expanded "><a href="bigint.html"><strong aria-hidden="true">4.</strong> Arbitrary Precision Integer</a></li><li class="chapter-item expanded "><a href="bitset.html"><strong aria-hidden="true">5.</strong> Bitset</a></li><li class="chapter-item expanded "><a href="io.html"><strong aria-hidden="true">6.</strong> Fast IO</a></li><li class="chapter-item expanded "><a href="scanf.html"><strong aria-hidden="true">7.</strong> scanf</a></li><li class="chapter-item expanded "><a href="f128.html"><strong aria-hidden="true">8.</strong> Float128</a></li><li class="chapter-item expanded affix "><li class="part-title">Math</li><li class="chapter-item expanded "><a href="gcd.html"><strong aria-hidden="true">9.</strong> GCD</a></li><li class="chapter-item expanded "><a href="rec.html"><strong aria-hidden="true">10.</strong> Linear Recurrence (Constant Coefficient)</a></li><li class="chapter-item expanded "><a href="cdiv.html"><strong aria-hidden="true">11.</strong> Constant Division / Modulo</a></li><li class="chapter-item expanded "><a href="ntt.html"><strong aria-hidden="true">12.</strong> Number Theoretic Transform</a></li><li class="chapter-item expanded affix "><li class="part-title">Geometry</li><li class="chapter-item expanded "><a href="convex-hull.html"><strong aria-hidden="true">13.</strong> Convex Hull</a></li><li class="chapter-item expanded "><a href="antipodes.html"><strong aria-hidden="true">14.</strong> Antipodal Points</a></li><li class="chapter-item expanded affix "><li class="part-title">Data Structures</li><li class="chapter-item expanded "><a href="segment-tree.html"><strong aria-hidden="true">15.</strong> Segment Tree</a></li><li class="chapter-item expanded "><a href="splay-tree.html"><strong aria-hidden="true">16.</strong> Splay Tree</a></li><li class="chapter-item expanded affix "><li class="part-title">Graphs</li><li class="chapter-item expanded "><a href="adjacency-array.html"><strong aria-hidden="true">17.</strong> Adjacency Array</a></li><li class="chapter-item expanded "><a href="hld.html"><strong aria-hidden="true">18.</strong> Heavy-Light Decomposition</a></li><li class="chapter-item expanded "><a href="flow.html"><strong aria-hidden="true">19.</strong> Push-Relabel Flow</a></li><li class="chapter-item expanded "><a href="heap.html"><strong aria-hidden="true">20.</strong> Min Heap</a></li><li class="chapter-item expanded affix "><li class="part-title">Strings</li><li class="chapter-item expanded "><a href="kmp.html"><strong aria-hidden="true">21.</strong> KMP</a></li><li class="chapter-item expanded "><a href="regex.html"><strong aria-hidden="true">22.</strong> Regex</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust PS Snippets</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><em>Rust has <strong>fancy</strong> ability to abstract algorithms. Why don't we use it in PS domain?</em></p>
<p>Many algorithms and data structures are exhausting and boring to implement every time.
You can copy ready-made implementations here and focus on the logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix"><a class="header" href="#matrix">Matrix</a></h1>
<pre><code class="language-rust noplayground">struct Matrix&lt;T&gt;(Vec&lt;T&gt;, usize);

impl&lt;T&gt; std::ops::Index&lt;usize&gt; for Matrix&lt;T&gt; {
    type Output = [T];
    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {
        &amp;self.0[index * self.1..][..self.1]
    }
}

impl&lt;T&gt; std::ops::IndexMut&lt;usize&gt; for Matrix&lt;T&gt; {
    fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut Self::Output {
        &amp;mut self.0[index * self.1..][..self.1]
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<pre><code class="language-rust noplayground">#[derive(Clone, Copy)]
enum Clause {
    Pos(usize),
    Neg(usize),
}
 
impl Clause {
    fn as_index(&amp;self) -&gt; usize {
        match self {
            Self::Pos(i) =&gt; i &lt;&lt; 1 | 1,
            Self::Neg(i) =&gt; i &lt;&lt; 1,
        }
    }
 
    fn inv(&amp;self) -&gt; Self {
        match *self {
            Self::Pos(i) =&gt; Self::Neg(i),
            Self::Neg(i) =&gt; Self::Pos(i),
        }
    }
}
 
#[derive(Default)]
struct SAT {
    head: Vec&lt;u32&gt;,
    link: Vec&lt;u32&gt;,
    end: Vec&lt;u32&gt;,
}
 
impl SAT {
    fn reserve_clause(&amp;mut self, n: usize) {
        self.head.resize(self.head.len() + n * 2, u32::MAX);
    }
 
    fn or(&amp;mut self, l: Clause, r: Clause) {
        self.connect(l.inv().as_index(), r.as_index());
        self.connect(r.inv().as_index(), l.as_index());
    }
 
    fn imply(&amp;mut self, l: Clause, r: Clause) {
        self.connect(l.as_index(), r.as_index());
        self.connect(r.inv().as_index(), l.inv().as_index());
    }
 
    fn connect(&amp;mut self, from: usize, to: usize) {
        let p = self.head[from];
        self.head[from] = self.link.len() as u32;
        self.link.push(p);
        self.end.push(to as u32);
    }
 
    fn try_assign(&amp;self) -&gt; Option&lt;Vec&lt;bool&gt;&gt; {
        let n = self.head.len();
        let mut c = 0;
        let mut s = vec![];
        let mut p = vec![];
        let mut pre = vec![u32::MAX; n];
        let mut comp = vec![u32::MAX; n];
        let mut next = 0;
        for i in 0..n {
            if pre[i] != u32::MAX {
                continue;
            }
            pre[i] = c;
            c += 1;
            let mut dfs = vec![(i as u32, self.head[i])];
            s.push(i as u32);
            p.push(i as u32);
            while let Some((u, e)) = dfs.last_mut() {
                if let Some(&amp;v) = self.end.get(*e as usize) {
                    if pre[v as usize] == u32::MAX {
                        pre[v as usize] = c;
                        c += 1;
                        s.push(v);
                        p.push(v);
                        dfs.push((v, self.head[v as usize]));
                        continue;
                    } else if comp[v as usize] == u32::MAX {
                        while let Some(&amp;w) = p.last() {
                            if pre[w as usize] &lt;= pre[v as usize] {
                                break;
                            }
                            p.pop();
                        }
                    }
                    *e = self.link[*e as usize];
                } else {
                    if Some(&amp;*u) == p.last() {
                        p.pop();
                        while let Some(v) = s.pop() {
                            if comp[v as usize ^ 1] == next {
                                return None;
                            }
                            comp[v as usize] = next;
                            if v == *u {
                                break;
                            }
                        }
                        next += 1;
                    }
                    dfs.pop();
                    if let Some((_, e)) = dfs.last_mut() {
                        *e = self.link[*e as usize];
                    }
                }
            }
        }
        Some(comp.chunks(2).map(|c| c[0] &gt; c[1]).collect())
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pseudo-random-number-generator"><a class="header" href="#pseudo-random-number-generator">Pseudo Random Number Generator</a></h1>
<p>Reference: https://github.com/BrutPitt/fastPRNG</p>
<pre><code class="language-rust noplayground">
struct Rng32([u32; 4]);

impl Rng32 {
    fn split_mix(v: u32) -&gt; u32 {
        let mut z = v.wrapping_add(0x9e3779b9);
        z = (z ^ (z &gt;&gt; 15)).wrapping_mul(0x85ebca6b);
        z = (z ^ (z &gt;&gt; 13)).wrapping_mul(0xc2b2ae35);
        z ^ (z &gt;&gt; 16)
    }
    fn new() -&gt; Self {
        let mut seed = 0;
        unsafe { std::arch::x86_64::_rdrand32_step(&amp;mut seed) };
        let mut prev = seed;
        Self(std::array::from_fn(|_| {
            prev = Self::split_mix(prev);
            prev
        }))
    }
    fn next(&amp;mut self, n: u32) -&gt; u32 {
        let [x, y, z, w] = &amp;mut self.0;
        let res = x.wrapping_add(*w);
        let t = x.wrapping_shl(9);
        *y ^= *x;
        *w ^= *y;
        *y ^= *z;
        *x ^= *w;
        *z ^= t;
        *w = w.rotate_left(11);
        ((res as u64 * n as u64) &gt;&gt; 32) as u32
    }
}

struct Rng64([u64; 4]);

impl Rng64 {
    fn split_mix(v: u64) -&gt; u64 {
        let mut z = v.wrapping_add(0x9e3779b97f4a7c15);
        z = (z ^ (z &gt;&gt; 30)).wrapping_mul(0xbf58476d1ce4e5b9);
        z = (z ^ (z &gt;&gt; 27)).wrapping_mul(0x94d049bb133111eb);
        z ^ (z &gt;&gt; 31)
    }
    fn new() -&gt; Self {
        let mut seed = 0;
        unsafe { std::arch::x86_64::_rdrand64_step(&amp;mut seed) };
        let mut prev = seed;
        Self(std::array::from_fn(|_| {
            prev = Self::split_mix(prev);
            prev
        }))
    }
    fn next(&amp;mut self, n: u64) -&gt; u64 {
        let [x, y, z, w] = &amp;mut self.0;
        let res = x.wrapping_add(*w);
        let t = x.wrapping_shl(17);
        *y ^= *x;
        *w ^= *y;
        *y ^= *z;
        *x ^= *w;
        *z ^= t;
        *w = w.rotate_left(45);
        ((res as u128 * n as u128) &gt;&gt; 64) as u64
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-precision-integer"><a class="header" href="#arbitrary-precision-integer">Arbitrary Precision Integer</a></h1>
<pre><code class="language-rust noplayground">#[derive(Clone, PartialEq, Eq)]
struct BigInt(bool, Vec&lt;u64&gt;);

impl std::str::FromStr for BigInt {
    type Err = std::convert::Infallible;
    fn from_str(mut s: &amp;str) -&gt; std::result::Result&lt;Self, Self::Err&gt; {
        let sign = s.starts_with(&quot;-&quot;);
        if sign {
            s = &amp;s[1..];
        }
        let size = (s.len() + RADIX_POW - 1) / RADIX_POW;
        let mut v = Vec::with_capacity(size);
        for c in s.as_bytes().rchunks(RADIX_POW) {
            let mut t = 0;
            for &amp;b in c {
                t *= 10;
                t += (b - b'0') as u64;
            }
            v.push(t);
        }
        Ok(Self(sign, v))
    }
}

impl std::fmt::Display for BigInt {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        if self.0 {
            write!(f, &quot;-&quot;)?;
        }
        let mut a = self.1.iter().rev();
        let last = *a.next().unwrap();
        write!(f, &quot;{last}&quot;)?;
        for l in a {
            write!(f, &quot;{l:00$}&quot;, RADIX_POW)?;
        }
        Ok(())
    }
}

impl std::cmp::PartialOrd for BigInt {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl std::cmp::Ord for BigInt {
    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
        use std::cmp::Ordering::*;
        if self.0 &amp;&amp; !other.0 {
            Less
        } else if !self.0 &amp;&amp; other.0 {
            Greater
        } else {
            let ord = if self.1.len() != other.1.len() {
                self.1.len().cmp(&amp;other.1.len())
            } else {
                let mut last = Equal;
                for (l, r) in self.1.iter().rev().zip(other.1.iter().rev()) {
                    last = l.cmp(r);
                    if last != Equal {
                        break;
                    }
                }
                last
            };
            if self.0 {
                match ord {
                    Less =&gt; Greater,
                    Equal =&gt; Equal,
                    Greater =&gt; Less,
                }
            } else {
                ord
            }
        }
    }
}

const RADIX: u64 = 1_000_000;
const RADIX_POW: usize = 6;
impl BigInt {
    fn new() -&gt; Self {
        Self(false, vec![0])
    }
    fn is_zero(&amp;self) -&gt; bool {
        self.1.len() == 1 &amp;&amp; self.1[0] == 0
    }
    fn normalize(&amp;mut self) {
        let len = self.1.iter().rposition(|&amp;l| l != 0).unwrap_or(0) + 1;
        self.1.truncate(len);
        if self.1.len() == 1 &amp;&amp; self.1[0] == 0 {
            self.0 = false;
        }
    }
    fn add(&amp;mut self, rhs: &amp;Self) {
        if self.0 == rhs.0 {
            self.unsigned_add_assign(rhs);
        } else {
            self.unsigned_sub_assign(rhs);
        }
    }
    fn sub(&amp;mut self, rhs: &amp;Self) {
        if self.0 == rhs.0 {
            self.unsigned_sub_assign(rhs);
        } else {
            self.unsigned_add_assign(rhs);
        }
    }
    fn divmod_scalar(&amp;mut self, rhs: u64) -&gt; u64 {
        let mut borrow = 0;
        for d in self.1.iter_mut().rev() {
            borrow *= RADIX;
            borrow += *d;
            (*d, borrow) = (borrow / rhs, borrow % rhs);
        }
        self.normalize();
        borrow
    }
    fn mul(&amp;mut self, rhs: &amp;Self) {
        const NTT_0_INV: u64 = 285212675;
        let pad = (self.1.len() + rhs.1.len() - 1).next_power_of_two();
        self.1.resize(pad, 0);
        let mut l = &amp;mut self.1;
        let mut r = vec![0; pad];
        r[..rhs.1.len()].copy_from_slice(&amp;rhs.1);
        let mut l1 = l.clone();
        let mut r1 = r.clone();
        NTT[0].run(&amp;mut l, false);
        NTT[0].run(&amp;mut r, false);
        for (l, r) in l.iter_mut().zip(r) {
            *l = NTT[0].m.rem(*l as u64 * r as u64);
        }
        NTT[0].run(&amp;mut l, true);
        NTT[1].run(&amp;mut l1, false);
        NTT[1].run(&amp;mut r1, false);
        for (l, r) in l1.iter_mut().zip(r1) {
            *l = NTT[1].m.rem(*l as u64 * r as u64);
        }
        NTT[1].run(&amp;mut l1, true);
        for (l, l1) in l.iter_mut().zip(l1) {
            let r = NTT[1].m.rem((l1 + NTT[1].m.1 - *l) * NTT_0_INV);
            *l += NTT[0].m.1 * r;
        }
        let mut carry = 0;
        for x in l {
            *x += carry;
            carry = *x / RADIX;
            *x %= RADIX;
        }
        while carry &gt; 0 {
            self.1.push(carry % RADIX);
            carry /= RADIX;
        }
        self.0 = self.0 != rhs.0;
        self.normalize();
    }
    fn unsigned_add_assign(&amp;mut self, rhs: &amp;Self) {
        if rhs.is_zero() {
            return;
        } else if self.is_zero() {
            self.0 = rhs.0;
            self.1 = rhs.1.clone();
            return;
        }
        let n = self.1.len().min(rhs.1.len());
        let mut carry = 0;
        for (l, &amp;r) in self.1[..n].iter_mut().zip(&amp;rhs.1) {
            *l += r;
            *l += carry;
            if *l &gt;= RADIX {
                *l -= RADIX;
                carry = 1;
            } else {
                carry = 0;
            }
        }
        for l in &amp;mut self.1[n..] {
            *l += carry;
            if *l &gt;= RADIX {
                *l -= RADIX;
                carry = 1;
            } else {
                carry = 0;
                break;
            }
        }
        for &amp;r in &amp;rhs.1[n..] {
            let mut l = r + carry;
            if l &gt;= RADIX {
                l -= RADIX;
                carry = 1;
            } else {
                carry = 0;
            }
            self.1.push(l);
        }
        if carry &gt; 0 {
            self.1.push(1);
        }
        self.normalize();
    }
    fn unsigned_sub_assign(&amp;mut self, rhs: &amp;Self) {
        if rhs.is_zero() {
            return;
        } else if self.is_zero() {
            self.0 = !rhs.0;
            self.1 = rhs.1.clone();
            return;
        }
        let less = self.1.len().saturating_sub(rhs.1.len());
        let mut a = self.1.iter_mut();
        let mut b = rhs.1.iter().chain(std::iter::repeat(&amp;0).take(less));
        let mut zero = true;
        let mut carry = 0;
        for (l, &amp;r) in a.by_ref().zip(b.by_ref()) {
            if zero {
                if r != 0 {
                    zero = false;
                    *l += RADIX - r;
                } else {
                    continue;
                }
            } else {
                *l += RADIX - 1 + carry - r;
            }
            if *l &gt;= RADIX {
                *l -= RADIX;
                carry = 1;
            } else {
                carry = 0;
            }
        }
        for &amp;r in b {
            let mut add;
            if zero {
                if r != 0 {
                    zero = false;
                    add = RADIX + carry - r;
                } else {
                    continue;
                }
            } else {
                add = RADIX - 1 + carry - r;
            }
            if add &gt;= RADIX {
                add -= RADIX;
                carry = 1;
            } else {
                carry = 0;
            }
            self.1.push(add);
        }
        if carry == 0 {
            self.0 = !self.0;
            let mut a = self.1.iter_mut().skip_while(|v| **v == 0);
            if let Some(first) = a.next() {
                *first = RADIX - *first;
                for v in a {
                    *v = RADIX - 1 - *v;
                }
            }
        }
        self.normalize();
    }
}

struct NttParam {
    m: ModU64,
    u: u64,
    ui: u64,
    s: u32,
}

static NTT: &amp;[NttParam] = &amp;[
    NttParam {
        m: ModU64::new(1107296257),
        u: 1087287097,
        ui: 623044540,
        s: 25,
    },
    NttParam {
        m: ModU64::new(1711276033),
        u: 969788637,
        ui: 1790856,
        s: 25,
    },
];

impl NttParam {
    fn run(&amp;self, a: &amp;mut [u64], inv: bool) {
        let n = a.len();
        if n == 1 {
            return;
        }
        let s = n.leading_zeros() + 1;
        for i in 0..n {
            let r = i.reverse_bits() &gt;&gt; s;
            if i &lt; r {
                a.swap(i, r);
            }
        }
        let u = if inv { self.ui } else { self.u };
        for k in 1..=n.trailing_zeros() {
            let mut wlen = u;
            for _ in k..self.s {
                wlen = self.m.rem(wlen * wlen);
            }
            let kh = 1 &lt;&lt; (k - 1);
            for i in 0..(n + (1 &lt;&lt; k) - 1) &gt;&gt; k {
                let i = i &lt;&lt; k;
                let mut w = 1;
                for j in 0..kh {
                    let u = a[i + j];
                    let v = self.m.rem(a[i + j + kh] * w);
                    let mut s = u + v;
                    if s &gt;= self.m.1 {
                        s -= self.m.1;
                    }
                    a[i + j] = s;
                    let mut d = u + self.m.1 - v;
                    if d &gt;= self.m.1 {
                        d -= self.m.1;
                    }
                    a[i + j + kh] = d;
                    w = self.m.rem(w * wlen);
                }
            }
        }
        if inv {
            let p = self.m.1 as i64;
            let ni = ((egcd(n as i64, p).1 % p + p) % p) as u64;
            for x in a {
                *x = self.m.rem(*x as u64 * ni);
            }
        }
    }
}

fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
    let (mut x, mut y, mut x1, mut y1) = (1, 0, 0, 1);
    while b != 0 {
        let q = a / b;
        (x, x1) = (x1, x - q * x1);
        (y, y1) = (y1, y - q * y1);
        (a, b) = (b, a - q * b);
    }
    (a, x, y)
}

#[derive(Copy, Clone)]
struct ModU64(u128, u64);

impl ModU64 {
    const fn new(div: u64) -&gt; Self {
        Self((!0u128 / div as u128).wrapping_add(1), div)
    }
    fn multop(a: u128, b: u64) -&gt; u64 {
        let mut bottom = (a as u64 as u128) * b as u128;
        bottom &gt;&gt;= 64;
        let top = (a &gt;&gt; 64) * b as u128;
        ((bottom + top) &gt;&gt; 64) as u64
    }
    fn rem(&amp;self, a: u64) -&gt; u64 {
        let low = self.0.wrapping_mul(a as u128);
        Self::multop(low, self.1)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitset"><a class="header" href="#bitset">Bitset</a></h1>
<pre><code class="language-rust noplayground">struct Bitset(Vec&lt;std::arch::x86_64::__m256i&gt;, usize);

impl Bitset {
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn new(n: usize) -&gt; Self {
        use std::arch::x86_64::*;
        let mut v = vec![];
        v.resize_with((n + 255) / 256, || unsafe { _mm256_setzero_si256() });
        Self(v, n)
    }
    fn len(&amp;self) -&gt; usize {
        self.1
    }
    fn get(&amp;self, i: usize) -&gt; bool {
        let b64 =
            unsafe { std::slice::from_raw_parts(self.0.as_ptr() as *const u64, self.0.len() * 4) };
        b64[i / 64] &amp; (1 &lt;&lt; (i % 64)) != 0
    }
    fn set(&amp;mut self, i: usize, v: bool) {
        let b64 = unsafe {
            std::slice::from_raw_parts_mut(self.0.as_mut_ptr() as *mut u64, self.0.len() * 4)
        };
        if v {
            b64[i / 64] |= 1 &lt;&lt; (i % 64);
        } else {
            b64[i / 64] &amp;= !(1 &lt;&lt; (i % 64));
        }
    }
    fn flip(&amp;mut self, i: usize) {
        let b64 = unsafe {
            std::slice::from_raw_parts_mut(self.0.as_mut_ptr() as *mut u64, self.0.len() * 4)
        };
        b64[i / 64] ^= 1 &lt;&lt; (i % 64);
    }
    fn shl(&amp;self, x: usize) -&gt; Self {
        let mut shl = unsafe { Self::new(self.len() + x) };
        let shl_b64 = unsafe {
            std::slice::from_raw_parts_mut(shl.0.as_mut_ptr().cast::&lt;u64&gt;(), (shl.len() + 63) / 64)
        };
        let b64 = unsafe {
            std::slice::from_raw_parts(self.0.as_ptr().cast::&lt;u64&gt;(), (self.len() + 63) / 64)
        };
        let x_chunk = x / 64;
        let x_inside = (x % 64) as u32;
        if x_inside == 0 {
            for (dest, &amp;src) in shl_b64.iter_mut().skip(x_chunk).zip(b64) {
                *dest = src.wrapping_shl(x_inside);
            }
        } else {
            let mut low = 0;
            for (dest, &amp;src) in shl_b64.iter_mut().skip(x_chunk).zip(b64) {
                *dest = src.wrapping_shl(x_inside) | low;
                low = src &gt;&gt; (64 - x_inside);
            }
            if shl_b64.len() &gt; b64.len() + x_chunk {
                *shl_b64.last_mut().unwrap() = low;
            }
        }
        shl
    }
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn or(&amp;mut self, other: &amp;Self) {
        for (a, &amp;b) in self.0.iter_mut().zip(&amp;other.0) {
            *a = std::arch::x86_64::_mm256_or_si256(*a, b);
        }
    }
    fn split_range(mut begin: usize, end: usize) -&gt; Option&lt;(usize, usize)&gt; {
        let back = end &amp; !255;
        if begin &amp; 255 != 0 {
            begin += 256 - (begin &amp; 255);
        }
        if begin &lt; back {
            Some((begin, back))
        } else {
            None
        }
    }
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn find_first_unset(&amp;self, l: usize, r: usize) -&gt; Option&lt;usize&gt; {
        let b64 =
            unsafe { std::slice::from_raw_parts(self.0.as_ptr() as *const u64, self.0.len() * 4) };
        if let Some((le, rb)) = Self::split_range(l, r) {
            for i in l..le {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) == 0 {
                    return Some(i);
                }
            }
            let mut mask = 0;
            if let Some(mut i) = self.0[le &gt;&gt; 8..rb &gt;&gt; 8].iter().position(|p| {
                use std::arch::x86_64::*;
                let v256 = unsafe { _mm256_load_si256(p) };
                let zero = unsafe { _mm256_set1_epi8(-1) };
                let nonzero = unsafe { _mm256_cmpeq_epi8(zero, v256) };
                mask = unsafe { _mm256_movemask_epi8(nonzero) } as u32;
                mask != !0
            }) {
                i += le &gt;&gt; 8;
                let j = (0..32).position(|s| mask &amp; (1 &lt;&lt; s) == 0).unwrap();
                let b8 = unsafe {
                    std::slice::from_raw_parts(self.0.as_ptr() as *const u8, self.0.len() * 32)
                };
                let k = b8[i * 32 + j].trailing_ones() as usize;
                let begin = (i * 32 + j) * 8 + k;
                return Some(begin);
            }
            for i in rb..r {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) == 0 {
                    return Some(i);
                }
            }
            None
        } else {
            for i in l..r {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) == 0 {
                    return Some(i);
                }
            }
            None
        }
    }
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn find_first_set(&amp;self, l: usize, r: usize) -&gt; Option&lt;usize&gt; {
        let b64 =
            unsafe { std::slice::from_raw_parts(self.0.as_ptr() as *const u64, self.0.len() * 4) };
        if let Some((le, rb)) = Self::split_range(l, r) {
            for i in l..le {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) != 0 {
                    return Some(i);
                }
            }
            let mut mask = 0;
            if let Some(mut i) = self.0[le &gt;&gt; 8..rb &gt;&gt; 8].iter().position(|p| {
                use std::arch::x86_64::*;
                let v256 = unsafe { _mm256_load_si256(p) };
                let zero = unsafe { _mm256_setzero_si256() };
                let nonzero = unsafe { _mm256_cmpeq_epi8(zero, v256) };
                mask = unsafe { _mm256_movemask_epi8(nonzero) } as u32;
                mask != !0
            }) {
                i += le &gt;&gt; 8;
                let j = (0..32).position(|s| mask &amp; (1 &lt;&lt; s) == 0).unwrap();
                let b8 = unsafe {
                    std::slice::from_raw_parts(self.0.as_ptr() as *const u8, self.0.len() * 32)
                };
                let k = b8[i * 32 + j].trailing_zeros() as usize;
                let begin = (i * 32 + j) * 8 + k;
                return Some(begin);
            }
            for i in rb..r {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) != 0 {
                    return Some(i);
                }
            }
            None
        } else {
            for i in l..r {
                if b64[i &gt;&gt; 6] &amp; (1 &lt;&lt; (i &amp; 63)) != 0 {
                    return Some(i);
                }
            }
            None
        }
    }
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn flip_range(&amp;mut self, l: usize, r: usize) {
        let b64 = std::slice::from_raw_parts_mut(self.0.as_mut_ptr() as *mut u64, self.0.len() * 4);
        if let Some((le, rb)) = Self::split_range(l, r) {
            use std::arch::x86_64::*;
            for i in l..le {
                b64[i &gt;&gt; 6] ^= 1 &lt;&lt; (i &amp; 63);
            }
            let one = _mm256_set1_epi8(-1);
            for v in &amp;mut self.0[le &gt;&gt; 8..rb &gt;&gt; 8] {
                let load = _mm256_load_si256(v);
                let xor = _mm256_xor_si256(load, one);
                _mm256_store_si256(v, xor);
            }
            for i in rb..r {
                b64[i &gt;&gt; 6] ^= 1 &lt;&lt; (i &amp; 63);
            }
        } else {
            for i in l..r {
                b64[i &gt;&gt; 6] ^= 1 &lt;&lt; (i &amp; 63);
            }
        }
    }
    #[target_feature(enable = &quot;avx2&quot;)]
    unsafe fn count_ones(&amp;mut self, l: usize, r: usize) -&gt; u32 {
        let b64 = std::slice::from_raw_parts_mut(self.0.as_mut_ptr() as *mut u64, self.0.len() * 4);
        let mut count = 0;
        if let Some((le, rb)) = Self::split_range(l, r) {
            use std::arch::x86_64::*;
            for i in l..le {
                if b64[i &gt;&gt; 6] &amp; 1 &lt;&lt; (i &amp; 63) != 0 {
                    count += 1;
                }
            }
            let b0 = _mm256_set1_epi32(0x55555555);
            let b1 = _mm256_set1_epi32(0x33333333);
            let b2 = _mm256_set1_epi32(0x0f0f0f0f);
            let b3 = _mm256_set1_epi32(0x01010101);
            let mut vcount = _mm256_setzero_si256();
            for v in &amp;mut self.0[le &gt;&gt; 8..rb &gt;&gt; 8] {
                let load = _mm256_load_si256(v);
                let c1 = _mm256_sub_epi32(load, _mm256_and_si256(b0, _mm256_srli_epi32::&lt;1&gt;(load)));
                let c2 = _mm256_add_epi32(
                    _mm256_and_si256(c1, b1),
                    _mm256_and_si256(_mm256_srli_epi32::&lt;2&gt;(c1), b1),
                );
                let c3 = _mm256_srli_epi32::&lt;24&gt;(_mm256_mullo_epi32(
                    _mm256_and_si256(_mm256_add_epi32(c2, _mm256_srli_epi32::&lt;4&gt;(c2)), b2),
                    b3,
                ));
                vcount = _mm256_add_epi32(vcount, c3);
            }
            let [a, b, c, d, e, f, g, h]: [u32; 8] = std::mem::transmute(vcount);
            count += a + b + c + d + e + f + g + h;
            for i in rb..r {
                if b64[i &gt;&gt; 6] &amp; 1 &lt;&lt; (i &amp; 63) != 0 {
                    count += 1;
                }
            }
        } else {
            for i in l..r {
                if b64[i &gt;&gt; 6] &amp; 1 &lt;&lt; (i &amp; 63) != 0 {
                    count += 1;
                }
            }
        }
        count
    }
}

impl std::fmt::Debug for Bitset {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        let b64 =
            unsafe { std::slice::from_raw_parts(self.0.as_ptr().cast::&lt;u64&gt;(), self.0.len() * 4) };
        let mut iter = b64.iter().rev().skip_while(|&amp;&amp;b| b == 0);
        if let Some(&amp;first) = iter.next() {
            write!(f, &quot;{first:b}&quot;)?;
            for &amp;b in iter {
                write!(f, &quot;{b:064b}&quot;)?;
            }
            Ok(())
        } else {
            write!(f, &quot;0&quot;)
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fast-io"><a class="header" href="#fast-io">Fast IO</a></h1>
<pre><code class="language-rust noplayground">struct Reader {
    begin: *const u8,
    cur: *const u8,
    end: *const u8,
    goff: usize,
    cap: usize,
}
impl Reader {
    fn new(capacity: usize) -&gt; Self {
        let ptr;
        unsafe {
            std::arch::asm!(
                &quot;syscall&quot;,
                inout(&quot;rax&quot;) 9usize =&gt; ptr,
                in(&quot;rdi&quot;) 0,
                in(&quot;rsi&quot;) capacity,
                in(&quot;rdx&quot;) 3,
                in(&quot;r10&quot;) 2,
                in(&quot;r8&quot;) 0,
                in(&quot;r9&quot;) 0,
                out(&quot;rcx&quot;) _,
                out(&quot;r11&quot;) _,
                options(nomem,preserves_flags)
            );
        }
        Self {
            begin: ptr,
            end: unsafe { ptr.add(capacity) },
            cur: ptr,
            goff: 0,
            cap: capacity,
        }
    }
    fn try_refill(&amp;mut self, readahead: usize) {
        if unsafe { self.cur.add(readahead) } &lt;= self.end {
            return;
        }
        self.goff += unsafe { self.cur.offset_from(self.begin) } as usize;
        let add = self.goff &amp; 4095;
        self.goff &amp;= !4095;
        let ptr;
        unsafe {
            std::arch::asm!(
                &quot;syscall&quot;,
                inout(&quot;rax&quot;) 9usize =&gt; ptr,
                in(&quot;rdi&quot;) self.begin,
                in(&quot;rsi&quot;) self.cap,
                in(&quot;rdx&quot;) 3,
                in(&quot;r10&quot;) 18,
                in(&quot;r8&quot;) 0,
                in(&quot;r9&quot;) self.goff,
                out(&quot;rcx&quot;) _,
                out(&quot;r11&quot;) _,
                options(nomem,preserves_flags)
            );
        }
        self.begin = ptr;
        self.cur = unsafe { self.begin.add(add) };
        self.end = unsafe { self.begin.add(self.cap) };
    }
    fn consume(&amp;mut self, add: usize) {
        self.cur = unsafe { self.cur.add(add) };
    }
    fn until(&amp;mut self, delim: u8, buf: &amp;mut String) -&gt; usize {
        #[target_feature(enable = &quot;avx2,sse4.2&quot;)]
        unsafe fn memchr(s: &amp;[u8], delim: u8) -&gt; Option&lt;usize&gt; {
            s.iter().position(|&amp;b| b == delim)
        }
        let mut total = 0;
        loop {
            let len = unsafe { self.end.offset_from(self.cur) } as usize;
            let range = unsafe { std::slice::from_raw_parts(self.cur, len) };
            if let Some(i) = unsafe { memchr(range, delim) } {
                unsafe { buf.as_mut_vec() }.extend_from_slice(&amp;range[..i]);
                self.cur = unsafe { self.cur.add(i + 1) };
                break total + i;
            } else {
                unsafe { buf.as_mut_vec() }.extend_from_slice(&amp;range);
                self.cur = self.end;
                self.try_refill(1);
                total += len;
            }
        }
    }
    fn remain(&amp;self) -&gt; &amp;[u8] {
        let len = unsafe { self.end.offset_from(self.cur) } as usize;
        unsafe { std::slice::from_raw_parts(self.cur, len) }
    }
    fn discard(&amp;mut self, until: u8) -&gt; usize {
        let mut len = 0;
        #[target_feature(enable = &quot;avx2&quot;)]
        unsafe fn index(s: &amp;[u8], b: u8) -&gt; Option&lt;usize&gt; {
            s.iter().position(|&amp;c| c == b)
        }
        loop {
            let pos = unsafe { index(self.remain(), until) };
            if let Some(pos) = pos {
                len += pos;
                self.cur = unsafe { self.cur.add(pos + 1) };
                break len;
            }
            len += unsafe { self.end.offset_from(self.cur) } as usize;
            self.cur = self.end;
            self.try_refill(1);
        }
    }

    fn i32(&amp;mut self) -&gt; i32 {
        let sign = unsafe { self.cur.read() } == b'-';
        (if sign {
            self.cur = unsafe { self.cur.add(1) };
            self.u32().wrapping_neg()
        } else {
            self.u32()
        }) as i32
    }
    fn u32(&amp;mut self) -&gt; u32 {
        let mut c = unsafe { self.cur.cast::&lt;u64&gt;().read_unaligned() };
        let m = !c &amp; 0x1010101010101010;
        let len = m.trailing_zeros() &gt;&gt; 3;
        c &lt;&lt;= (8 - len) &lt;&lt; 3;
        c = (c &amp; 0x0F0F0F0F0F0F0F0F).wrapping_mul(2561) &gt;&gt; 8;
        c = (c &amp; 0x00FF00FF00FF00FF).wrapping_mul(6553601) &gt;&gt; 16;
        c = (c &amp; 0x0000FFFF0000FFFF).wrapping_mul(42949672960001) &gt;&gt; 32;
        self.cur = unsafe { self.cur.add(len as usize) };
        if len == 8 {
            if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                c *= 10;
                c += (unsafe { self.cur.read() } - b'0') as u64;
                self.cur = unsafe { self.cur.add(1) };
            }
            if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                c *= 10;
                c += (unsafe { self.cur.read() } - b'0') as u64;
                self.cur = unsafe { self.cur.add(1) };
            }
        }
        self.cur = unsafe { self.cur.add(1) };
        c as u32
    }
    fn i64(&amp;mut self) -&gt; i64 {
        let sign = unsafe { self.cur.read() } == b'-';
        (if sign {
            self.cur = unsafe { self.cur.add(1) };
            self.u64().wrapping_neg()
        } else {
            self.u64()
        }) as i64
    }
    fn u64(&amp;mut self) -&gt; u64 {
        let mut c = unsafe { self.cur.cast::&lt;u64&gt;().read_unaligned() };
        let m = !c &amp; 0x1010101010101010;
        let len = m.trailing_zeros() &gt;&gt; 3;
        c &lt;&lt;= (8 - len) &lt;&lt; 3;
        c = (c &amp; 0x0F0F0F0F0F0F0F0F).wrapping_mul(2561) &gt;&gt; 8;
        c = (c &amp; 0x00FF00FF00FF00FF).wrapping_mul(6553601) &gt;&gt; 16;
        c = (c &amp; 0x0000FFFF0000FFFF).wrapping_mul(42949672960001) &gt;&gt; 32;
        self.cur = unsafe { self.cur.add(len as usize) };
        if len == 8 &amp;&amp; unsafe { self.cur.read() } &amp; 16 != 0 {
            let mut d = unsafe { self.cur.cast::&lt;u64&gt;().read_unaligned() };
            let m = !d &amp; 0x1010101010101010;
            let len = m.trailing_zeros() &gt;&gt; 3;
            for _ in 0..len {
                c *= 10;
            }
            d &lt;&lt;= (8 - len) &lt;&lt; 3;
            d = (d &amp; 0x0F0F0F0F0F0F0F0F).wrapping_mul(2561) &gt;&gt; 8;
            d = (d &amp; 0x00FF00FF00FF00FF).wrapping_mul(6553601) &gt;&gt; 16;
            d = (d &amp; 0x0000FFFF0000FFFF).wrapping_mul(42949672960001) &gt;&gt; 32;
            c += d;
            self.cur = unsafe { self.cur.add(len as usize) };
            if len == 8 {
                if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                    c *= 10;
                    c += (unsafe { self.cur.read() } - b'0') as u64;
                    self.cur = unsafe { self.cur.add(1) };
                }
                if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                    c *= 10;
                    c += (unsafe { self.cur.read() } - b'0') as u64;
                    self.cur = unsafe { self.cur.add(1) };
                }
                if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                    c *= 10;
                    c += (unsafe { self.cur.read() } - b'0') as u64;
                    self.cur = unsafe { self.cur.add(1) };
                }
                if unsafe { self.cur.read() } &amp; 0x10 != 0 {
                    c *= 10;
                    c += (unsafe { self.cur.read() } - b'0') as u64;
                    self.cur = unsafe { self.cur.add(1) };
                }
            }
        }
        self.cur = unsafe { self.cur.add(1) };
        c
    }
}
struct Writer {
    buf: Vec&lt;u8&gt;,
    off: usize,
}
impl Drop for Writer {
    fn drop(&amp;mut self) {
        self.flush();
    }
}
#[repr(align(16))]
struct B128([u8; 16]);
#[target_feature(enable = &quot;avx2&quot;)]
unsafe fn cvt8(out: &amp;mut B128, n: u32) -&gt; usize {
    use std::arch::x86_64::*;
    let x = _mm_cvtsi32_si128(n as i32);
    let div_10000 = _mm_set1_epi32(0xd1b71759u32 as i32);
    let mul_10000_merge = _mm_set1_epi32(55536);
    let div_var = _mm_setr_epi16(
        8389,
        5243,
        13108,
        0x8000u16 as i16,
        8389,
        5243,
        13108,
        0x8000u16 as i16,
    );
    let shift_var = _mm_setr_epi16(
        1 &lt;&lt; 7,
        1 &lt;&lt; 11,
        1 &lt;&lt; 13,
        (1 &lt;&lt; 15) as i16,
        1 &lt;&lt; 7,
        1 &lt;&lt; 11,
        1 &lt;&lt; 13,
        (1 &lt;&lt; 15) as i16,
    );
    let mul_10 = _mm_set1_epi16(10);
    let ascii0 = _mm_set1_epi8(48);
    let x_div_10000 = _mm_srli_epi64::&lt;45&gt;(_mm_mul_epu32(x, div_10000));
    let y = _mm_add_epi32(x, _mm_mul_epu32(x_div_10000, mul_10000_merge));
    let t0 = _mm_slli_epi16::&lt;2&gt;(_mm_shuffle_epi32::&lt;5&gt;(_mm_unpacklo_epi16(y, y)));
    let t1 = _mm_mulhi_epu16(t0, div_var);
    let t2 = _mm_mulhi_epu16(t1, shift_var);
    let t3 = _mm_slli_epi64::&lt;16&gt;(t2);
    let t4 = _mm_mullo_epi16(t3, mul_10);
    let t5 = _mm_sub_epi16(t2, t4);
    let t6 = _mm_packus_epi16(_mm_setzero_si128(), t5);
    let mask = _mm_movemask_epi8(_mm_cmpeq_epi8(t6, _mm_setzero_si128()));
    let offset = (mask &amp; !0x8000).trailing_ones() as usize;
    let ascii = _mm_add_epi8(t6, ascii0);
    _mm_store_si128(out.0.as_mut_ptr().cast(), ascii);
    offset
}
impl Writer {
    fn new(capacity: usize) -&gt; Self {
        let mut buf = vec![];
        buf.reserve_exact(capacity);
        unsafe { buf.set_len(capacity) };
        Self { buf, off: 0 }
    }
    fn flush(&amp;mut self) {
        unsafe {
            std::arch::asm!(
                &quot;syscall&quot;,
                inout(&quot;rax&quot;) 1 =&gt; _,
                in(&quot;rdi&quot;) 1,
                in(&quot;rsi&quot;) self.buf.as_ptr(),
                in(&quot;rdx&quot;) self.off,
                out(&quot;rcx&quot;) _,
                out(&quot;r11&quot;) _,
                options(readonly,preserves_flags)
            )
        }
        self.off = 0;
    }
    fn try_flush(&amp;mut self, readahead: usize) {
        if self.off + readahead &gt; self.buf.len() {
            self.flush();
        }
    }
    fn byte(&amp;mut self, b: u8) {
        self.try_flush(1);
        self.buf[self.off] = b;
        self.off += 1;
    }
    fn bytes(&amp;mut self, s: &amp;[u8]) {
        let mut i = 0;
        while i &lt; s.len() {
            let rem = s[i..].len().min(self.buf[self.off..].len());
            self.buf[self.off..self.off + rem].copy_from_slice(&amp;s[i..i + rem]);
            self.off += rem;
            i += rem;
            if self.off == self.buf.len() {
                self.flush();
            }
        }
    }
    fn i32(&amp;mut self, n: i32) {
        if n &lt; 0 {
            self.byte(b'-');
            self.u32((n as u32).wrapping_neg());
        } else {
            self.u32(n as u32);
        }
    }
    fn u32(&amp;mut self, n: u32) {
        let mut b128 = B128([0u8; 16]);
        let mut off;
        if n &gt;= 100_000_000 {
            self.try_flush(10);
            let mut hi = n / 100_000_000;
            let lo = n % 100_000_000;
            unsafe { cvt8(&amp;mut b128, lo) };
            off = 8;
            off -= 1;
            b128.0[off] = (hi % 10) as u8 + b'0';
            if hi &gt;= 10 {
                off -= 1;
                hi /= 10;
                b128.0[off] = hi as u8 + b'0';
            }
        } else {
            self.try_flush(8);
            off = unsafe { cvt8(&amp;mut b128, n) };
        }
        let len = 16 - off;
        self.buf[self.off..self.off + len].copy_from_slice(&amp;b128.0[off..]);
        self.off += len;
    }
    fn i64(&amp;mut self, n: i64) {
        if n &lt; 0 {
            self.byte(b'-');
            self.u64((n as u64).wrapping_neg());
        } else {
            self.u64(n as u64);
        }
    }
    fn u64(&amp;mut self, n: u64) {
        let mut hi128 = B128([0u8; 16]);
        let mut lo128 = B128([0u8; 16]);
        let mut hioff;
        let looff;
        if n &gt;= 10_000_000_000_000_000 {
            self.try_flush(20);
            let mut hi = (n / 10_000_000_000_000_000) as u32;
            let lo = n % 10_000_000_000_000_000;
            let lohi = (lo / 100_000_000) as u32;
            let lolo = (lo % 100_000_000) as u32;
            unsafe { cvt8(&amp;mut hi128, lohi) };
            unsafe { cvt8(&amp;mut lo128, lolo) };
            hioff = 8;
            looff = 8;
            hioff -= 1;
            hi128.0[hioff] = (hi % 10) as u8 + b'0';
            if hi &gt;= 10 {
                hioff -= 1;
                hi /= 10;
                hi128.0[hioff] = (hi % 10) as u8 + b'0';
            }
            if hi &gt;= 10 {
                hioff -= 1;
                hi /= 10;
                hi128.0[hioff] = (hi % 10) as u8 + b'0';
            }
            if hi &gt;= 10 {
                hioff -= 1;
                hi /= 10;
                hi128.0[hioff] = hi as u8 + b'0';
            }
        } else if n &gt;= 100_000_000 {
            self.try_flush(16);
            let hi = (n / 100_000_000) as u32;
            let lo = (n % 100_000_000) as u32;
            hioff = unsafe { cvt8(&amp;mut hi128, hi) };
            unsafe { cvt8(&amp;mut lo128, lo) };
            looff = 8;
        } else {
            self.try_flush(8);
            hioff = 16;
            looff = unsafe { cvt8(&amp;mut lo128, n as u32) };
        }
        let len = 16 - hioff;
        self.buf[self.off..self.off + len].copy_from_slice(&amp;hi128.0[hioff..]);
        self.off += len;
        let len = 16 - looff;
        self.buf[self.off..self.off + len].copy_from_slice(&amp;lo128.0[looff..]);
        self.off += len;
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scanf"><a class="header" href="#scanf">Scanf</a></h1>
<p>You can use scanf. Not the best API, but I think it fits best for PS area.</p>
<pre><code class="language-rust noplayground">fn solve() {
    scanf!(&quot;%d%d&quot;, a: i32, b: i32);
    println!(&quot;{}&quot;, a + b);
    scanf!(&quot;%s&quot;, name: [u8; 32]);
    println!(&quot;{name}&quot;);
}

fn main() {
    unsafe {
        *stdin |= 0x8000;
        STDOUT = Some(BufWriter::with_capacity(1 &lt;&lt; 17, File::from_raw_fd(1)));
    }
    solve();
    unsafe {
        STDOUT.as_mut().unwrap_unchecked().flush().ok();
        _exit(0);
    }
}

use std::{fs::File, io::*, os::unix::io::FromRawFd};

static mut STDOUT: Option&lt;BufWriter&lt;File&gt;&gt; = None;

#[macro_export]
macro_rules! println {
    ($($t:tt)*) =&gt; { unsafe { writeln!(STDOUT.as_mut().unwrap_unchecked(), $($t)*).unwrap_unchecked() } };
}
#[macro_export]
macro_rules! print {
    ($($t:tt)*) =&gt; { unsafe { write!(STDOUT.as_mut().unwrap_unchecked(), $($t)*).unwrap_unchecked() } };
}
#[macro_export]
macro_rules! flush {
    () =&gt; {
        unsafe {
            STDOUT
                .as_mut()
                .unwrap_unchecked()
                .flush()
                .unwrap_unchecked()
        }
    };
}

#[macro_export]
macro_rules! scanf {
    ($fmt:literal $(, $($t:tt)+)?) =&gt; {
        scanf!(@def $($($t)+)?);
        scanf!(@call $($($t)+)?, $fmt);
        scanf!(@bind $($($t)+)?);
    };
    (@def) =&gt; {};
    (@def $(mut)? $name:ident: [u8; $size:expr] $(, $($t:tt)+)?) =&gt; {
        let mut $name = vec![0u8; $size + 1];
        scanf!(@def $($($t)+)?);
    };
    (@def $(mut)? $name:ident: $ty:ty $(, $($t:tt)+)?) =&gt; {
        let mut $name = std::mem::MaybeUninit::&lt;$ty&gt;::uninit();
        scanf!(@def $($($t)+)?);
    };
    ($($names:ident),* @call $fmt:literal) =&gt; {
        unsafe {
            fscanf(stdin, concat!($fmt, &quot;\0&quot;).as_ptr(), $($names.as_mut_ptr()),*);
        };
    };
    ($($names:ident),* @call $(mut)? $name:ident: [u8; $size:expr] $(, $($t:tt)+)?) =&gt; {
        scanf!($($names,)* $name @call $($($t)+)?);
    };
    ($($names:ident),* @call $(mut)? $name:ident: $ty:ty $(, $($t:tt)+)?) =&gt; {
        scanf!($($names,)* $name @call $($($t)+)?);
    };
    (@bind) =&gt; {};
    (@bind $name:ident: [u8; $size:expr] $(, $($t:tt)+)?) =&gt; {
        $name.pop();
        let $name = unsafe { String::from_utf8_unchecked($name) };
        scanf!(@bind $($($t)+)?);
    };
    (@bind mut $name:ident: [u8; $size:expr] $(, $($t:tt)+)?) =&gt; {
        $name.pop();
        let mut $name = unsafe { String::from_utf8_unchecked($name) };
        scanf!(@bind $($($t)+)?);
    };
    (@bind $name:ident: $ty:ty $(, $($t:tt)+)?) =&gt; {
        let $name = unsafe { $name.assume_init() };
        scanf!(@bind $($($t)+)?);
    };
    (@bind mut $name:ident: $ty:ty $(, $($t:tt)+)?) =&gt; {
        let mut $name = unsafe { $name.assume_init() };
        scanf!(@bind $($($t)+)?);
    };
}

#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn fscanf(file: *mut usize, fmt: *const u8, ...) -&gt; i32;
    fn _exit(code: i32) -&gt; !;
    static stdin: *mut usize;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float128"><a class="header" href="#float128">Float128</a></h1>
<pre><code class="language-rust noplayground">#[derive(Clone, Copy)]
#[allow(non_camel_case_types)]
struct f128(std::arch::x86_64::__m128);

macro_rules! impl_float {
    (from $t:ty: $from:ident $to:ident) =&gt; {
        impl From&lt;$t&gt; for f128 {
            fn from(v: $t) -&gt; Self {
                unsafe { $from(v) }
            }
        }
        impl From&lt;f128&gt; for $t {
            fn from(v: f128) -&gt; Self {
                unsafe { $to(v) }
            }
        }
    };
    (op $trait:ident $method:ident $func:ident) =&gt; {
        impl std::ops::$trait&lt;Self&gt; for f128 {
            type Output = Self;
            fn $method(self, o: Self) -&gt; Self {
                unsafe { $func(self, o) }
            }
        }
    };
}
impl_float!(from f64: __extenddftf2 __trunctfdf2);
impl_float!(from i64: __floattitf __fixtfti);
impl_float!(from u64: __floatuntitf __fixunstfti);
impl_float!(from i32: __floatsitf __fixtfsi);
impl_float!(from u32: __floatunsitf __fixunstfsi);
impl_float!(op Add add __addtf3);
impl_float!(op Sub sub __subtf3);
impl_float!(op Mul mul __multf3);
impl_float!(op Div div __divtf3);
impl std::ops::Neg for f128 {
    type Output = Self;
    fn neg(self) -&gt; Self::Output {
        unsafe { __negtf3(self) }
    }
}
impl std::cmp::PartialEq for f128 {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        unsafe { __eqtf2(*self, *other) == 0 }
    }
}
impl std::cmp::Eq for f128 {}
impl std::cmp::PartialOrd for f128 {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;std::cmp::Ordering&gt; {
        Some(self.cmp(other))
    }
}
impl std::cmp::Ord for f128 {
    fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
        unsafe { __cmptf2(*self, *other).cmp(&amp;0) }
    }
}

#[link(name = &quot;stdc++&quot;)]
#[allow(improper_ctypes)]
extern &quot;C&quot; {
    fn __extenddftf2(a: f64) -&gt; f128;
    fn __trunctfdf2(a: f128) -&gt; f64;
    fn __addtf3(a: f128, b: f128) -&gt; f128;
    fn __subtf3(a: f128, b: f128) -&gt; f128;
    fn __multf3(a: f128, b: f128) -&gt; f128;
    fn __divtf3(a: f128, b: f128) -&gt; f128;
    fn __negtf3(a: f128) -&gt; f128;
    fn __fixtfsi(a: f128) -&gt; i32;
    fn __fixunstfsi(a: f128) -&gt; u32;
    fn __fixtfti(a: f128) -&gt; i64;
    fn __fixunstfti(a: f128) -&gt; u64;
    fn __floatsitf(a: i32) -&gt; f128;
    fn __floatunsitf(a: u32) -&gt; f128;
    fn __floattitf(a: i64) -&gt; f128;
    fn __floatuntitf(a: u64) -&gt; f128;
    fn __eqtf2(a: f128, b: f128) -&gt; i32;
    fn __cmptf2(a: f128, b: f128) -&gt; i32;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcd"><a class="header" href="#gcd">GCD</a></h1>
<pre><code class="language-rust noplayground">fn gcd(mut a: i32, mut b: i32) -&gt; i32 {
    if a == 0 || b == 0 {
        a + b
    } else {
        let az = a.trailing_zeros();
        let bz = b.trailing_zeros();
        let s = az.min(bz);
        a &gt;&gt;= az;
        b &gt;&gt;= bz;
        while a != 0 {
            let d = a - b;
            (a, b) = (d.abs(), a.min(b));
            a &gt;&gt;= d.trailing_zeros();
        }
        b &lt;&lt; s
    }
}

/// Returns 3-tuple `(g, x, y)` that satisfies ax + by = g = gcd(a, b).
fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
    let (mut x, mut y, mut x1, mut y1) = (1, 0, 0, 1);
    while b != 0 {
        let q = a / b;
        (x, x1) = (x1, x - q * x1);
        (y, y1) = (y1, y - q * y1);
        (a, b) = (b, a - q * b);
    }
    (a, x, y)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-recurrence-constant-coefficient"><a class="header" href="#linear-recurrence-constant-coefficient">Linear Recurrence (Constant Coefficient)</a></h1>
<p>Calculates nth element of linearly recurrent sequence {an}, given initial values and coefficients.</p>
<p>Time complexity: O(klogn), where k is the length of coefficients.</p>
<pre><code class="language-rust noplayground">const M: u64 = 998244353;
const M32: u32 = M as u32;
fn recurrence(init: impl AsRef&lt;[u32]&gt;, coef: impl AsRef&lt;[u32]&gt;, n: usize) -&gt; u32 {
    let init = init.as_ref();
    let coef = coef.as_ref();
    let k = init.len();
    assert_eq!(k, coef.len());
    if n &lt; k {
        return init[n];
    }
    let mut acc = vec![0; k * k];
    for i in 0..k {
        acc[i * k + i] = 1;
    }
    let mut mult = vec![0; k * (k - 1)];
    for i in 1..k {
        mult[(i - 1) * k + i] = 1;
    }
    mult.extend_from_slice(coef);
    let mut aux = vec![0; k * k];
    let t = (n - k + 1..=n).min_by_key(|t| t.count_ones()).unwrap();
    for s in 0..64 - t.leading_zeros() {
        if t &amp; (1 &lt;&lt; s) != 0 {
            multiply(k, &amp;acc, &amp;mult, &amp;mut aux);
            (acc, aux) = (aux, acc);
        }
        multiply(k, &amp;mult, &amp;mult, &amp;mut aux);
        (mult, aux) = (aux, mult);
    }
    let mut result = 0;
    for (&amp;y, &amp;x) in init.iter().zip(&amp;acc[(n - t) * k..]) {
        result += (y as u64 * x as u64 % M) as u32;
        if result &gt;= M32 {
            result -= M32;
        }
    }
    result
}

fn multiply(n: usize, a: &amp;[u32], b: &amp;[u32], c: &amp;mut [u32]) {
    for i in 0..n {
        for j in 0..n {
            c[i * n + j] = 0;
            for k in 0..n {
                c[i * n + j] += (a[i * n + k] as u64 * b[k * n + j] as u64 % M) as u32;
                if c[i * n + j] &gt;= M32 {
                    c[i * n + j] -= M32;
                }
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constant-division--modulo"><a class="header" href="#constant-division--modulo">Constant Division / Modulo</a></h1>
<p>Speed up division and modulo calculation using precomputation.</p>
<p>reference: <a href="https://lemire.me/blog/2019/02/20/more-fun-with-fast-remainders-when-the-divisor-is-a-constant/">Daniel Lemire</a></p>
<pre><code class="language-rust noplayground">#[derive(Copy, Clone)]
struct ModU32(u64, u32);

impl ModU32 {
    const fn new(div: u32) -&gt; Self {
        Self((!0 / div as u64).wrapping_add(1), div)
    }
    const fn rem(&amp;self, a: u32) -&gt; u32 {
        let low = self.0.wrapping_mul(a as u64);
        ((low as u128 * self.1 as u128) &gt;&gt; 64) as u32
    }
    const fn quot(&amp;self, a: u32) -&gt; u32 {
        ((self.0 as u128 * a as u128) &gt;&gt; 64) as u32
    }
    const fn quotrem(&amp;self, a: u32) -&gt; (u32, u32) {
        let full = self.0 as u128 * a as u128;
        let quot = full &gt;&gt; 64;
        let rem = (full as u64 as u128 * self.1 as u128) &gt;&gt; 64;
        (quot as u32, rem as u32)
    }
    const fn divisible(&amp;self, a: u32) -&gt; bool {
        self.0.wrapping_mul(a as u64) &lt;= self.0.wrapping_sub(1)
    }
}

/// d != 0 &amp;&amp; d != i32::MIN
#[derive(Copy, Clone)]
struct ModI32(u64, i32);

impl ModI32 {
    const fn new(div: i32) -&gt; Self {
        let abs = div.abs();
        let mut m = (!0 / abs as u64).wrapping_add(1);
        if (abs &amp; (abs - 1)) == 0 {
            m += 1;
        }
        Self(m, div)
    }
    const fn rem(&amp;self, a: i32) -&gt; i32 {
        let low = self.0.wrapping_mul(a as u64);
        let high = ((low as u128 * self.1.abs() as u128) &gt;&gt; 64) as i32;
        high - ((self.1 - 1) &amp; (a &gt;&gt; 31))
    }
    const fn quot(&amp;self, a: i32) -&gt; i32 {
        let mut high = ((self.0 as i128 * a as i128) &gt;&gt; 64) as u64;
        if a &lt; 0 {
            high = high.wrapping_add(1);
        }
        if self.1 &lt; 0 {
            -(high as i32)
        } else {
            high as i32
        }
    }
    const fn quotrem(&amp;self, a: i32) -&gt; (i32, i32) {
        let full = self.0 as i128 * a as i128;
        let mut high = (full &gt;&gt; 64) as u64;
        if a &lt; 0 {
            high = high.wrapping_add(1);
        }
        let quot = if self.1 &lt; 0 {
            -(high as i32)
        } else {
            high as i32
        };
        let mut rem = ((full as u64 as u128 * self.1.abs() as u128) &gt;&gt; 64) as i32;
        rem -= ((self.1 - 1) &amp; a &gt;&gt; 31);
        (quot, rem)
    }
}

#[derive(Copy, Clone)]
struct ModU64(u128, u64);

impl ModU64 {
    const fn new(div: u64) -&gt; Self {
        Self((!0u128 / div as u128).wrapping_add(1), div)
    }
    const fn multop(a: u128, b: u64) -&gt; u64 {
        let mut bottom = (a as u64 as u128) * b as u128;
        bottom &gt;&gt;= 64;
        let top = (a &gt;&gt; 64) * b as u128;
        ((bottom + top) &gt;&gt; 64) as u64
    }
    const fn rem(&amp;self, a: u64) -&gt; u64 {
        let low = self.0.wrapping_mul(a as u128);
        Self::multop(low, self.1)
    }
    const fn quot(&amp;self, a: u64) -&gt; u64 {
        Self::multop(self.0, a)
    }
    const fn divisible(&amp;self, a: u64) -&gt; bool {
        self.0.wrapping_mul(a as u128) &lt;= self.0.wrapping_sub(1)
    }
}

#[derive(Copy, Clone)]
struct BarrettU32(u64, u32);

impl BarrettU32 {
    fn new(div: u32) -&gt; Self {
        Self(!0u64 / div as u64, div)
    }
    fn quot(&amp;self, a: u64) -&gt; u64 {
        ((self.0 as u128 * a as u128) &gt;&gt; 64) as u64
    }
    fn rem(&amp;self, a: u64) -&gt; u32 {
        (a - self.quot(a) * self.1 as u64) as u32
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-theoretic-transform"><a class="header" href="#number-theoretic-transform">Number Theoretic Transform</a></h1>
<pre><code class="language-rust noplayground">struct NttParam {
    m: ModU64,
    u: u64,
    ui: u64,
    s: u32,
}

static NTT: &amp;[NttParam] = &amp;[NttParam {
    m: ModU64::new(998244353),
    u: 15311432,
    ui: 469870224,
    s: 23,
}, NttParam {
    m: ModU64::new(1107296257),
    u: 1087287097,
    ui: 623044540,
    s: 25,
}, NttParam {
    m: ModU64::new(1711276033),
    u: 969788637,
    ui: 1790856,
    s: 25,
}];

impl NttParam {
    fn run(&amp;self, a: &amp;mut [u32], inv: bool) {
        let n = a.len();
        let s = n.leading_zeros() + 1;
        for i in 0..n {
            let r = i.reverse_bits() &gt;&gt; s;
            if i &lt; r {
                a.swap(i, r);
            }
        }
        let u = if inv { self.ui } else { self.u };
        for k in 1..=n.trailing_zeros() {
            let mut wlen = u;
            for _ in k..self.s {
                wlen = self.m.rem(wlen * wlen);
            }
            let kh = 1 &lt;&lt; (k - 1);
            for i in 0..(n + (1 &lt;&lt; k) - 1) &gt;&gt; k {
                let i = i &lt;&lt; k;
                let mut w = 1;
                for j in 0..kh {
                    let u = a[i + j] as u64;
                    let v = self.m.rem(a[i + j + kh] as u64 * w);
                    let mut s = u + v;
                    if s &gt;= self.m.1 {
                        s -= self.m.1;
                    }
                    a[i + j] = s as u32;
                    let mut d = u + self.m.1 - v;
                    if d &gt;= self.m.1 {
                        d -= self.m.1;
                    }
                    a[i + j + kh] = d as u32;
                    w = self.m.rem(w * wlen);
                }
            }
        }
        if inv {
            let p = self.m.1 as i64;
            let ni = ((egcd(n as i64, p).1 % p + p) % p) as u64;
            for x in a {
                *x = self.m.rem(*x as u64 * ni) as u32;
            }
        }
    }
}

fn egcd(mut a: i64, mut b: i64) -&gt; (i64, i64, i64) {
    let (mut x, mut y, mut x1, mut y1) = (1, 0, 0, 1);
    while b != 0 {
        let q = a / b;
        (x, x1) = (x1, x - q * x1);
        (y, y1) = (y1, y - q * y1);
        (a, b) = (b, a - q * b);
    }
    (a, x, y)
}

#[derive(Copy, Clone)]
struct ModU64(u128, u64);

impl ModU64 {
    const fn new(div: u64) -&gt; Self {
        Self((!0u128 / div as u128).wrapping_add(1), div)
    }
    fn multop(a: u128, b: u64) -&gt; u64 {
        let mut bottom = (a as u64 as u128) * b as u128;
        bottom &gt;&gt;= 64;
        let top = (a &gt;&gt; 64) * b as u128;
        ((bottom + top) &gt;&gt; 64) as u64
    }
    fn rem(&amp;self, a: u64) -&gt; u64 {
        let low = self.0.wrapping_mul(a as u128);
        Self::multop(low, self.1)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="convex-hull-monotone-chain"><a class="header" href="#convex-hull-monotone-chain">Convex Hull (Monotone Chain)</a></h1>
<p>Returns points in convex hull in counterclockwise order.</p>
<p>Removes straight points. change <code>is_ge()</code> (resp. <code>is_le()</code>) to <code>.is_gt()</code> (resp. <code>is_lt</code>) to contain straight points.</p>
<pre><code class="language-rust noplayground">fn convex_hull(sorted_pts: &amp;[(i32, i32)]) -&gt; Vec&lt;(i32, i32)&gt; {
    let mut hull = vec![];
    let mut len = 0;
    for &amp;p in sorted_pts.iter() {
        while len &gt;= 2 &amp;&amp; turn(hull[len - 2], hull[len - 1], p).is_le() {
            hull.pop();
            len -= 1;
        }
        hull.push(p);
        len += 1;
    }
    let down = len;
    let mut len = 0;
    for &amp;p in sorted_pts.iter() {
        while len &gt;= 2 &amp;&amp; turn(hull[down + len - 2], hull[down + len - 1], p).is_ge() {
            hull.pop();
            len -= 1;
        }
        hull.push(p);
        len += 1;
    }
    let mut offset = 0;
    let mut j = 0;
    for i in down..hull.len() {
        let p = hull[i];
        hull[i - offset] = p;
        while j &lt; down {
            match hull[j].cmp(&amp;p) {
                std::cmp::Ordering::Less =&gt; j += 1,
                std::cmp::Ordering::Equal =&gt; {
                    offset += 1;
                    break;
                }
                std::cmp::Ordering::Greater =&gt; break,
            }
        }
    }
    hull.truncate(hull.len() - offset);
    hull[down..].reverse();
    hull
}

// Less =&gt; cw
// Greater =&gt; ccw
fn turn((ax, ay): (i32, i32), (bx, by): (i32, i32), (cx, cy): (i32, i32)) -&gt; std::cmp::Ordering {
    let abx = (bx - ax) as i64;
    let aby = (by - ay) as i64;
    let bcx = (cx - bx) as i64;
    let bcy = (cy - by) as i64;
    (abx * bcy).cmp(&amp;(aby * bcx))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="antipodal-points"><a class="header" href="#antipodal-points">Antipodal Points</a></h1>
<p>An iterator that yields every antipodal pairs.</p>
<pre><code class="language-rust noplayground">struct Antipodes&lt;T&gt; {
    i: usize,
    p: T,
    q: T,
    p1: T,
    q1: T,
}

impl&lt;'a, T&gt; Iterator for Antipodes&lt;std::iter::Peekable&lt;T&gt;&gt;
where
    T: Iterator&lt;Item = &amp;'a (i32, i32)&gt; + Clone,
{
    type Item = ((i32, i32), (i32, i32));

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.i == 0 {
            return None;
        }
        self.i -= 1;
        let p = **self.p.peek()?;
        let p1 = **self.p1.peek()?;
        let q = **self.q.peek()?;
        let q1 = **self.q1.peek()?;
        if cross(p, p1, q) &lt; cross(p, p1, q1) {
            self.q = self.q1.clone();
            Some((**self.p.peek()?, *self.q1.next()?))
        } else {
            self.p = self.p1.clone();
            Some((*self.p1.next()?, **self.q.peek()?))
        }
    }
}

impl&lt;'a&gt; Antipodes&lt;std::iter::Peekable&lt;std::iter::Cycle&lt;std::slice::Iter&lt;'a, (i32, i32)&gt;&gt;&gt;&gt; {
    fn from_hull(hull: &amp;'a [(i32, i32)]) -&gt; Self {
        let mut base = hull.iter().cycle().peekable();
        let mut p = base.clone();
        base.next();
        let mut p1 = base.clone();
        let mut q = base.clone();
        base.next();
        let mut q1 = base;
        let pp = **p.peek().unwrap();
        let pp1 = **p1.peek().unwrap();
        while cross(pp, pp1, **q.peek().unwrap()) &lt; cross(pp, pp1, **q1.peek().unwrap()) {
            q = q1.clone();
            q1.next();
        }
        let i = hull.len();
        Self { i, p, p1, q, q1 }
    }
}

// Less =&gt; cw
// Greater =&gt; ccw
fn turn(a: (i32, i32), b: (i32, i32), c: (i32, i32)) -&gt; std::cmp::Ordering {
    cross(a, b, c).cmp(&amp;0)
}

fn cross((ax, ay): (i32, i32), (bx, by): (i32, i32), (cx, cy): (i32, i32)) -&gt; i64 {
    let abx = (bx - ax) as i64;
    let aby = (by - ay) as i64;
    let bcx = (cx - bx) as i64;
    let bcy = (cy - by) as i64;
    abx * bcy - aby * bcx
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree"><a class="header" href="#segment-tree">Segment Tree</a></h1>
<pre><code class="language-rust noplayground">struct SegTree&lt;C, A, T&gt; {
    e: T,
    v: Vec&lt;T&gt;,
    offset: usize,
    n: usize,
    combine: C,
    apply: A,
}

impl&lt;C, A, T&gt; SegTree&lt;C, A, T&gt;
where
    T: Copy,
    C: Fn(T, T) -&gt; T,
{
    fn new&lt;I&gt;(n: usize, e: T, combine: C, apply: A, init: I) -&gt; Self
    where
        I: IntoIterator&lt;Item = T&gt;,
    {
        let offset = n;
        let mut v = vec![e; offset];
        v.extend(init.into_iter().take(n));
        v.resize(offset * 2, e);
        for i in (1..offset).rev() {
            v[i] = combine(v[i &lt;&lt; 1], v[i &lt;&lt; 1 | 1]);
        }
        Self {
            e,
            v,
            offset,
            n,
            combine,
            apply,
        }
    }

    fn query&lt;B: std::ops::RangeBounds&lt;usize&gt;&gt;(&amp;self, range: B) -&gt; T {
        use std::ops::Bound::*;
        let mut l = self.offset
            + match range.start_bound() {
                Included(&amp;x) =&gt; x,
                Excluded(&amp;x) =&gt; x + 1,
                Unbounded =&gt; 0,
            };
        let mut r = self.offset
            + match range.end_bound() {
                Included(&amp;x) =&gt; x + 1,
                Excluded(&amp;x) =&gt; x,
                Unbounded =&gt; self.n,
            };
        let mut lsum = self.e;
        let mut rsum = self.e;
        while l &lt; r {
            if l &amp; 1 != 0 {
                lsum = (self.combine)(lsum, self.v[l]);
                l += 1;
            }
            if r &amp; 1 != 0 {
                r -= 1;
                rsum = (self.combine)(self.v[r], rsum);
            }
            l &gt;&gt;= 1;
            r &gt;&gt;= 1;
        }
        (self.combine)(lsum, rsum)
    }

    fn update&lt;U&gt;(&amp;mut self, mut i: usize, u: U)
    where
        U: Copy,
        A: Fn(&amp;mut T, U),
    {
        i += self.offset;
        (self.apply)(&amp;mut self.v[i], u);
        while i &gt; 1 {
            i &gt;&gt;= 1;
            self.v[i] = (self.combine)(self.v[i &lt;&lt; 1], self.v[i &lt;&lt; 1 | 1]);
        }
    }

    fn partition_point&lt;P: Fn(T) -&gt; bool&gt;(&amp;self, left: usize, pred: P) -&gt; usize {
        let mut p = left + self.offset;
        let mut value = self.e;
        loop {
            if p &amp; 1 != 0 {
                if pred((self.combine)(value, self.v[p])) {
                value = (self.combine)(value, self.v[p]);
                    p += 1;
                } else {
                    break;
                }
            }
            p &gt;&gt;= 1;
        }
        while p &lt; self.offset {
            p &lt;&lt;= 1;
            if pred((self.combine)(value, self.v[p])) {
                value = (self.combine)(value, self.v[p]);
                p |= 1;
            }
        }
        p - self.offset
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="splay-tree"><a class="header" href="#splay-tree">Splay Tree</a></h1>
<p>Top-down Splay Tree, supports lazy operations.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering::*;

trait SplayOp {
    type T;
    fn pull(_s: &amp;mut Splay&lt;Self&gt;) {}
    fn push(_s: &amp;mut Splay&lt;Self&gt;) {}
}

struct Splay&lt;Op: SplayOp + ?Sized&gt; {
    c: [Option&lt;Box&lt;Self&gt;&gt;; 2],
    k: u32,
    v: Op::T,
}

impl&lt;Op: SplayOp&gt; Splay&lt;Op&gt; {
    fn new(v: Op::T) -&gt; Box&lt;Self&gt; {
        Box::new(Self {
            c: [None, None],
            k: 1,
            v,
        })
    }
    fn pull(&amp;mut self) {
        let l = self.c[0].as_ref().map_or(0, |c| c.k);
        let r = self.c[1].as_ref().map_or(0, |c| c.k);
        self.k = l + r + 1;
        Op::pull(self);
    }
    fn push(&amp;mut self) {
        Op::push(self);
    }
    fn split(&amp;mut self, side: usize) -&gt; Option&lt;Box&lt;Self&gt;&gt; {
        self.push();
        let c = self.c[side].take();
        self.pull();
        c
    }
    fn join(&amp;mut self, side: usize, tree: Option&lt;Box&lt;Self&gt;&gt;) {
        self.push();
        assert!(self.c[side].is_none());
        self.c[side] = tree;
        self.pull();
    }
    fn index(self: Box&lt;Self&gt;, k: usize) -&gt; Box&lt;Self&gt; {
        let mut k = k as u32;
        self.find(|s| {
            let l = s.c[0].as_ref().map_or(0, |c| c.k);
            match k.cmp(&amp;l) {
                Equal =&gt; 2,
                Less =&gt; 0,
                Greater =&gt; {
                    k -= l + 1;
                    1
                }
            }
        })
    }
    fn find&lt;F&gt;(self: Box&lt;Self&gt;, mut f: F) -&gt; Box&lt;Self&gt;
    where
        F: FnMut(&amp;Self) -&gt; usize,
    {
        let mut current = self;
        let mut tree = [vec![], vec![]];
        loop {
            current.push();
            let i = f(&amp;current);
            if let Some(mut c) = current.c.get_mut(i).and_then(Option::take) {
                c.push();
                let j = f(&amp;c);
                if let Some(cc) = c.c.get_mut(j).and_then(Option::take) {
                    if i == j {
                        let rotate = c.c[j ^ 1].take();
                        current.c[i] = rotate;
                        current.pull();
                        c.c[j ^ 1] = Some(current);
                        tree[j ^ 1].push(c);
                    } else {
                        tree[j].push(current);
                        tree[i].push(c);
                    }
                    current = cc;
                } else {
                    tree[i ^ 1].push(current);
                    current = c;
                    break;
                }
            } else {
                break;
            }
        }
        current.push();
        let [mut left, mut right] = current.c;
        let [ltree, rtree] = tree;
        for mut l in ltree.into_iter().rev() {
            l.c[1] = left;
            l.pull();
            left = Some(l);
        }
        for mut r in rtree.into_iter().rev() {
            r.c[0] = right;
            r.pull();
            right = Some(r);
        }
        current.c = [left, right];
        current.pull();
        current
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjacency-array"><a class="header" href="#adjacency-array">Adjacency Array</a></h1>
<p>Graphs are represented with <strong>Adjacency Array</strong>s.
All edges on the graph are stored in a single array
such that edges with the same starting vertex are connected like a linked list.</p>
<ul>
<li><code>link</code> stores (previous edge index, endpoint) tuples.</li>
<li><code>head</code> stores indices of edge list heads (or <code>u32::MAX</code> if none).</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Graph {
    head: Vec&lt;u32&gt;,
    link: Vec&lt;(u32, u32)&gt;,
}

impl Graph {
    fn new(v: usize, e: usize) -&gt; Self {
        Self {
            head: vec![u32::MAX; v],
            link: Vec::with_capacity(e),
        }
    }
    fn connect(&amp;mut self, from: usize, to: usize) {
        let prev = self.head[from];
        self.head[from] = self.link.len() as u32;
        self.link.push((prev, to as u32));
    }
    fn neighbor(&amp;self, u: usize) -&gt; Neighbor {
        Neighbor(self, self.head[u])
    }
}

struct Neighbor&lt;'a&gt;(&amp;'a Graph, u32);

impl&lt;'a&gt; Iterator for Neighbor&lt;'a&gt; {
    // (edge index, endpoint)
    type Item = (usize, usize);
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let e = self.1;
        let (next, endpoint) = *self.0.link.get(self.1 as usize)?;
        self.1 = next;
        Some((e as usize, endpoint as usize))
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heavy-light-decomposition"><a class="header" href="#heavy-light-decomposition">Heavy-Light Decomposition</a></h1>
<p>Path traversing on heavy-light decomposition can be elegantly
represented with Rust Iterator.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Hld {
    p: Vec&lt;u32&gt;,
    d: Vec&lt;u32&gt;,
    r: Vec&lt;u32&gt;,
}

impl Graph {
    fn hld(&amp;self, root: usize) -&gt; Hld {
        let n = self.head.len();
        let mut d = vec![0; n];
        let mut p = vec![0; n];
        p[root] = root as u32;
        let mut bfs = vec![(root as u32, 0, 1, 0)];
        let mut front = 0;
        let mut depth = 0;
        while front &lt; bfs.len() {
            let back = bfs.len();
            for i in front..back {
                let u = bfs[i].0 as usize;
                let pu = p[u];
                d[u] = depth;
                for (_, v) in self.neighbor(u) {
                    if v == pu as usize {
                        continue;
                    }
                    bfs.push((v as u32, i as u32, 1, 0));
                    p[v] = u as u32;
                }
            }
            front = back;
            depth += 1;
        }
        let bfs = &amp;mut bfs[..];
        for i in (1..bfs.len()).rev() {
            let (_, p, sz, _) = bfs[i];
            let (_, _, usz, umax) = &amp;mut bfs[p as usize];
            *usz += sz;
            *umax = sz.max(*umax);
        }
        let mut r = vec![0; n];
        for i in 1..bfs.len() {
            let (v, p, sz, _) = bfs[i];
            let (u, _, _, umax) = &amp;mut bfs[p as usize];
            if sz == *umax {
                r[v as usize] = *u;
                *umax = u32::MAX;
                bfs[i].0 = *u;
            } else {
                r[v as usize] = v;
            }
        }
        Hld { p, d, r }
    }
}

impl Hld {
    fn path(&amp;self, u: usize, v: usize) -&gt; HldPath {
        HldPath { hld: self, u, v }
    }
    fn lca(&amp;self, mut u: usize, mut v: usize) -&gt; usize {
        while self.r[u] != self.r[v] {
            if self.d[self.r[u] as usize] &gt; self.d[self.r[v] as usize] {
                std::mem::swap(&amp;mut u, &amp;mut v);
            }
            v = self.p[self.r[v] as usize] as usize;
        }
        if self.d[u] &gt; self.d[v] {
            v
        } else {
            u
        }
    }
}

struct HldPath&lt;'a&gt; {
    hld: &amp;'a Hld,
    u: usize,
    v: usize,
}

impl Iterator for HldPath&lt;'_&gt; {
    // (upper, lower)
    type Item = (usize, usize);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.u == usize::MAX {
            return None;
        }
        let ru = self.hld.r[self.u] as usize;
        let mut rv = self.hld.r[self.v] as usize;
        if ru == rv {
            let ret = if self.hld.d[self.u] &gt; self.hld.d[self.v] {
                (self.v, self.u)
            } else {
                (self.u, self.v)
            };
            self.u = usize::MAX;
            Some(ret)
        } else {
            if self.hld.d[ru] &gt; self.hld.d[rv] {
                (rv, self.u, self.v) = (ru, self.v, self.u);
            }
            self.v = self.hld.p[rv] as usize;
            Some((rv, self.v))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push-relabel-flow"><a class="header" href="#push-relabel-flow">Push-Relabel Flow</a></h1>
<pre><code class="language-rust noplayground">type Capacity = i32;
struct Flow {
    head: Vec&lt;u32&gt;,
    link: Vec&lt;(u32, u32)&gt;,
    f: Vec&lt;Capacity&gt;,
    x: Vec&lt;Capacity&gt;,
    next: Vec&lt;i32&gt;,
    last: Vec&lt;i32&gt;,
    gn: Vec&lt;i32&gt;,
    gp: Vec&lt;i32&gt;,
    ff: Vec&lt;u32&gt;,
    h: Vec&lt;i32&gt;,
    high: i32,
    high_gap: i32,
    work: usize,
}

impl Flow {
    fn new(v: usize, e: usize) -&gt; Self {
        Self {
            head: vec![u32::MAX; v],
            link: Vec::with_capacity(e),
            f: Vec::with_capacity(e),
            x: Vec::with_capacity(e),
            gn: vec![],
            gp: vec![],
            h: vec![],
            high: 0,
            high_gap: 0,
            work: 0,
            next: vec![],
            last: vec![],
            ff: vec![],
        }
    }
    fn connect(&amp;mut self, from: usize, to: usize, cap: Capacity, directed: bool) {
        let p = self.head[from];
        self.head[from] = self.link.len() as u32;
        self.link.push((p, to as u32));
        self.f.push(cap);
        let p = self.head[to];
        self.head[to] = self.link.len() as u32;
        self.link.push((p, from as u32));
        self.f.push(if directed { 0 } else { cap });
    }
    fn push_last(&amp;mut self, h: i32, u: usize) {
        self.next[u] = self.last[h as usize];
        self.last[h as usize] = u as i32;
    }
    fn update_h(&amp;mut self, u: usize, mut new_h: i32) {
        if self.h[u] as usize != self.head.len() {
            self.gn[self.gp[u] as usize] = self.gn[u];
            self.gp[self.gn[u] as usize] = self.gp[u];
        }
        self.h[u] = new_h as i32;
        if new_h == self.head.len() as i32 {
            return;
        }
        self.high_gap = self.high_gap.max(new_h);
        if self.x[u] &gt; 0 {
            self.high = self.high.max(new_h);
            self.push_last(new_h, u);
        }
        new_h += self.head.len() as i32;
        self.gn[u] = self.gn[new_h as usize];
        self.gp[u] = new_h as i32;
        self.gn[new_h as usize] = u as i32;
        self.gp[self.gn[u] as usize] = u as i32;
    }
    fn global_relabel(&amp;mut self, t: usize) {
        self.work = 0;
        self.h.clear();
        self.h
            .extend(std::iter::repeat(self.head.len() as i32).take(self.head.len()));
        self.last.clear();
        self.last.resize(self.head.len(), -1);
        self.gn[..self.head.len()]
            .iter_mut()
            .enumerate()
            .for_each(|(i, v)| *v = i as i32);
        self.gp[..self.head.len()]
            .iter_mut()
            .enumerate()
            .for_each(|(i, v)| *v = i as i32);
        self.h[t] = 0;
        let mut q = vec![t as u32];
        let mut i = 0;
        while let Some(&amp;u) = q.get(i) {
            let mut e = self.head[u as usize];
            while let Some(&amp;(next, v)) = self.link.get(e as usize) {
                if self.h[v as usize] == self.head.len() as i32 &amp;&amp; self.f[(e ^ 1) as usize] &gt; 0 {
                    q.push(v);
                    self.update_h(v as usize, self.h[u as usize] + 1);
                }
                e = next;
            }
            self.high_gap = self.h[u as usize];
            self.high = self.high_gap;
            i += 1;
        }
    }
    fn push(&amp;mut self, u: usize, v: usize, e: usize) {
        let df = self.x[u].min(self.f[e]);
        if df &lt;= 0 {
            return;
        }
        if self.x[v] == 0 {
            self.push_last(self.h[v], v as usize);
        }
        self.f[e] -= df;
        self.f[e ^ 1] += df;
        self.x[u] -= df;
        self.x[v] += df;
    }
    fn discharge(&amp;mut self, u: usize) {
        let mut new_h = self.head.len() as i32;
        let mut e = self.ff[u];
        while let Some(&amp;(next, v)) = self.link.get(e as usize) {
            if self.f[e as usize] &gt; 0 {
                if self.h[u] == self.h[v as usize] + 1 {
                    self.push(u, v as usize, e as usize);
                    if self.x[u] &lt;= 0 {
                        self.ff[u] = e;
                        return;
                    }
                } else {
                    new_h = new_h.min(self.h[v as usize] + 1);
                }
            }
            e = next;
        }
        let mut e = self.head[u];
        while e != self.ff[u] {
            let (next, v) = self.link[e as usize];
            if self.f[e as usize] &gt; 0 {
                if self.h[u] == self.h[v as usize] + 1 {
                    self.push(u, v as usize, e as usize);
                    if self.x[u] &lt;= 0 {
                        self.ff[u] = e;
                        return;
                    }
                } else {
                    new_h = new_h.min(self.h[v as usize] + 1);
                }
            }
            e = next;
        }
        self.work += 1;
        let h = self.h[u] + self.head.len() as i32;
        if self.gn[self.gn[h as usize] as usize] != h {
            self.update_h(u, new_h);
        } else {
            let old = self.h[u];
            for h in old..=self.high_gap {
                let mut u = self.gn[(h + self.head.len() as i32) as usize] as usize;
                while u &lt; self.head.len() {
                    self.h[u] = self.head.len() as i32;
                    u = self.gn[u] as usize;
                }
                let uh = h + self.head.len() as i32;
                self.gp[uh as usize] = uh;
                self.gn[uh as usize] = uh;
            }
            self.high_gap = old - 1;
        }
    }
    fn run(&amp;mut self, s: usize, t: usize) -&gt; Capacity {
        self.ff.clear();
        self.ff.extend_from_slice(&amp;self.head);
        self.x.clear();
        self.x.resize(self.head.len(), 0);
        self.x[s] = Capacity::MAX;
        self.x[t] = -Capacity::MAX;
        self.gn.clear();
        self.gn.resize(self.head.len() * 2, 0);
        self.gp.clear();
        self.gp.resize(self.head.len() * 2, 0);
        self.next.clear();
        self.next.resize(self.head.len(), 0);
        self.global_relabel(t);
        let mut e = self.head[s];
        while let Some(&amp;(next, v)) = self.link.get(e as usize) {
            self.push(s, v as usize, e as usize);
            e = next;
        }
        while self.high &gt;= 0 {
            while self.last[self.high as usize] != -1 {
                let u = self.last[self.high as usize];
                self.last[self.high as usize] = self.next[u as usize];
                if self.h[u as usize] == self.high {
                    self.discharge(u as usize);
                    if self.work &gt; 4 * self.head.len() {
                        self.global_relabel(t);
                    }
                }
            }
            self.high -= 1;
        }
        self.x[t] + i32::MAX
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min-heap"><a class="header" href="#min-heap">Min Heap</a></h1>
<ul>
<li><code>pop()</code> - Returns (inserted index, key) pair.</li>
</ul>
<pre><code class="language-rs noplayground">struct MinHeap&lt;K&gt; {
    k: Vec&lt;(u32, K)&gt;,
    pos: Vec&lt;u32&gt;,
    max: usize,
}

impl&lt;K&gt; MinHeap&lt;K&gt;
where
    K: PartialOrd + Copy,
{
    fn new() -&gt; Self {
        Self {
            k: vec![],
            pos: vec![],
            max: 0,
        }
    }
    fn len(&amp;self) -&gt; usize {
        self.k.len()
    }
    fn push(&amp;mut self, k: K) {
        let i = self.max;
        let len = self.len() as u32;
        self.max += 1;
        self.k.push((i as u32, k));
        self.pos.push(len);
        self.up(i);
    }
    fn pop(&amp;mut self) -&gt; Option&lt;(usize, K)&gt; {
        if self.len() == 0 {
            return None;
        }
        let (i, k) = self.k.swap_remove(0);
        if self.len() &gt; 0 {
            self.pos[self.k[0].0 as usize] = 0;
            self.down(0);
        }
        Some((i as usize, k))
    }
    fn replace(&amp;mut self, i: usize, k: K) -&gt; K {
        use std::cmp::Ordering::*;
        let pos = self.pos[i] as usize;
        let ordering = self.k[pos].1.partial_cmp(&amp;k).unwrap();
        let prev = std::mem::replace(&amp;mut self.k[pos].1, k);
        match ordering {
            Greater =&gt; self.up(pos),
            Less =&gt; self.down(pos),
            Equal =&gt; {}
        }
        prev
    }
    fn up(&amp;mut self, mut pos: usize) {
        while pos &gt; 0 {
            let parent = (pos - 1) / 2;
            if self.k[pos].1 &gt;= self.k[parent].1 {
                break;
            }
            self.k.swap(pos, parent);
            self.pos[self.k[pos].0 as usize] = pos as u32;
            pos = parent;
        }
        self.pos[self.k[pos].0 as usize] = pos as u32;
    }
    fn down(&amp;mut self, mut pos: usize) {
        let len = self.len();
        loop {
            let child = pos * 2 + 1;
            if child &gt;= len {
                break;
            }
            let less = if child + 1 == len || self.k[child].1 &lt;= self.k[child + 1].1 {
                child
            } else {
                child + 1
            };
            if self.k[pos].1 &lt;= self.k[less].1 {
                break;
            }
            self.k.swap(less, pos);
            self.pos[self.k[pos].0 as usize] = pos as u32;
            pos = less;
        }
        self.pos[self.k[pos].0 as usize] = pos as u32;
    }
}

impl&lt;K&gt; FromIterator&lt;K&gt; for MinHeap&lt;K&gt;
where
    K: PartialOrd + Copy,
{
    fn from_iter&lt;T: IntoIterator&lt;Item = K&gt;&gt;(iter: T) -&gt; Self {
        let k: Vec&lt;_&gt; = iter
            .into_iter()
            .enumerate()
            .map(|(i, v)| (i as u32, v))
            .collect();
        let len = k.len();
        let pos = (0..len as u32).collect();
        let mut inst = Self { k, pos, max: len };
        for i in (0..inst.len()).rev() {
            inst.down(i);
        }
        inst
    }
}
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Single Source Shortest Path (Dijkstra's)</p>
<pre><code class="language-rs noplayground">fn sssp(g: &amp;Graph, w: &amp;[u32], s: usize) -&gt; Vec&lt;u32&gt; {
    let mut d = vec![u32::MAX; g.head.len()];
    d[s] = 0;
    let mut heap = d.iter().map(|&amp;d| d).collect::&lt;MinHeap&lt;_&gt;&gt;();
    while let Some((u, du)) = heap.pop() {
        for (e, v) in g.neighbor(u) {
            let dv = du + w[e &gt;&gt; 1] as u32;
            if d[v] &gt; dv {
                d[v] = dv;
                heap.replace(v, dv);
            }
        }
    }
    d
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kmp"><a class="header" href="#kmp">KMP</a></h1>
<pre><code class="language-rust noplayground">
struct Kmp&lt;'a, I, T&gt; {
    pi: Vec&lt;u32&gt;,
    haystack: I,
    needle: &amp;'a [T],
    i: usize,
}

impl&lt;'a, I, T&gt; Kmp&lt;'a, I, T&gt; {
    fn new&lt;H&gt;(haystack: H, needle: &amp;'a [T], pi: Vec&lt;u32&gt;) -&gt; Self
    where
        H: IntoIterator&lt;IntoIter = I&gt;,
    {
        Self {
            pi,
            haystack: haystack.into_iter(),
            needle,
            i: 0,
        }
    }
}

impl&lt;I, T, B&gt; Iterator for Kmp&lt;'_, I, T&gt;
where
    T: PartialEq,
    B: std::borrow::Borrow&lt;T&gt;,
    I: Iterator&lt;Item = B&gt;,
{
    type Item = usize;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let c = self.haystack.next()?;
        loop {
            if self.needle.get(self.i) == Some(c.borrow()) {
                self.i += 1;
                break;
            } else if self.i == 0 {
                break;
            } else {
                self.i = self.pi[self.i - 1] as usize;
            }
        }
        Some(self.i)
    }
}</code></pre>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">fn main() {
</span>let haystack = b&quot;AABABAABABAA&quot;;
let needle = b&quot;ABA&quot;;
let mut kmp = Kmp::new(&amp;needle[1..], needle, vec![0]);
while let Some(pi) = kmp.next() {
    kmp.pi.push(pi as u32);
}
for (i, len) in Kmp::new(haystack, needle, kmp.pi).enumerate() {
    if len &gt; 0 {
        println!(&quot;Partial match [{}, {}]&quot;, i + 1 - len, i);
    }
}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Kmp&lt;'a, I, T&gt; {
</span><span class="boring">    pi: Vec&lt;u32&gt;,
</span><span class="boring">    haystack: I,
</span><span class="boring">    needle: &amp;'a [T],
</span><span class="boring">    i: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, I, T&gt; Kmp&lt;'a, I, T&gt; {
</span><span class="boring">    fn new&lt;H&gt;(haystack: H, needle: &amp;'a [T], pi: Vec&lt;u32&gt;) -&gt; Self
</span><span class="boring">    where
</span><span class="boring">        H: IntoIterator&lt;IntoIter = I&gt;,
</span><span class="boring">    {
</span><span class="boring">        Self {
</span><span class="boring">            pi,
</span><span class="boring">            haystack: haystack.into_iter(),
</span><span class="boring">            needle,
</span><span class="boring">            i: 0,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;I, T, B&gt; Iterator for Kmp&lt;'_, I, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: PartialEq,
</span><span class="boring">    B: std::borrow::Borrow&lt;T&gt;,
</span><span class="boring">    I: Iterator&lt;Item = B&gt;,
</span><span class="boring">{
</span><span class="boring">    type Item = usize;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        let c = self.haystack.next()?;
</span><span class="boring">        loop {
</span><span class="boring">            if self.needle.get(self.i) == Some(c.borrow()) {
</span><span class="boring">                self.i += 1;
</span><span class="boring">                break;
</span><span class="boring">            } else if self.i == 0 {
</span><span class="boring">                break;
</span><span class="boring">            } else {
</span><span class="boring">                self.i = self.pi[self.i - 1] as usize;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        Some(self.i)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex"><a class="header" href="#regex">Regex</a></h1>
<p>Use POSIX library function.</p>
<pre><code class="language-rust noplayground">struct Regexp([u64; 8]);
extern &quot;C&quot; {
    fn regcomp(preg: *mut u64, pattern: *const u8, flags: i32);
    fn regexec(preg: *const u64, s: *const u8, n_expr: usize, m: *mut i32, flags: i32) -&gt; i32;
}

impl Regexp {
    fn new(pattern: &amp;str, case_insensitive: bool) -&gt; Self {
        let flag = if case_insensitive { 3 } else { 1 };
        let mut tmp = pattern.as_bytes().to_vec();
        tmp.push(0);
        let mut v = [0; 8];
        unsafe { regcomp(v.as_mut_ptr(), tmp.as_ptr(), flag) };
        Self(v)
    }

    fn find(&amp;self, text: &amp;str) -&gt; Option&lt;(usize, usize)&gt; {
        let mut text = text.as_bytes().to_vec();
        text.push(0);
        let mut m = [0; 2];
        let result = unsafe { regexec(self.0.as_ptr(), text.as_ptr(), 1, m.as_mut_ptr(), 0) };
        if result == 0 {
            Some((m[0] as usize, m[1] as usize))
        } else {
            None
        }
    }
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
